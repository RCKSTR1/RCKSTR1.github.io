---
layout: post
title: 'Gráficas con ng2-charts (Chart.js) y Angular 8. Ordena, filtra, mapea y reduce arreglos de objetos.'
description: 'Demo: GLTrack 4ta parte. Una aplicación para monitorear niveles de glucosa para pacientes de diabetes.'
image: assets/images/blog/GLTrack3/Banner-GLTrack3.jpg
---

<div class="post-content">
    <iframe allow="encrypted-media" allowtransparency="true" class="image left" frameborder="0" height="300"
        src="https://open.spotify.com/embed/playlist/0HOaqWkjGIaGvaxpCt4T7U" width="300"></iframe>

    <h2>Introducción</h2>
    <p>
        Esta es la cuarta y última parte de la serie de posts “GLTrack”. Durante los 4 posts hemos construido una
        aplicación que permite a los pacientes de diabetes llevar un registro de sus mediciones diarias de niveles de
        glucosa en la sangre.
    </p>

    <p>
        En el post anterior, comenzamos a construir la página principal de la aplicación e implementamos un componente
        que muestra una tabla con los datos de niveles de glucosa capturador por el usuario.
    </p>
    <p>
        Hoy implementaremos gráficas de línea, barras y pastel para representar de manera visual los datos cargados en
        el sistema.
    </p>

    <p>
        Comenzaremos corrigiendo un bug que encontré mientras trabajaba en este post. El bug quedó corregido también en
        los repositorios de GitHub de los posts anteriores.
    </p>

    <blockquote>
        Puedes revisar los 3 posts anteriores en los siguientes links:
        <ol>
            <li>
                <i>
                    <a href="{% link _posts/2019-6-18-GLTrack1.md %}" target="_blank">
                        GLTrack parte 1: "Schematics, Componentes y Ruteo con Angular + Material".
                    </a>
                </i>
            </li>
            <li>
                <i>
                    <a href="{% link _posts/2019-8-07-GLTrack2.md %}" target="_blank">
                        GLTrack parte 2: "Modelos, servicios, dependency injection, formas y data binding con Angular +
                        Material".
                    </a>
                </i>
            </li>
            <li>
                <i>
                    <a href="{% link _posts/2019-8-22-GLTrack3.md %}" target="_blank">
                        GLTrack parte 3: "Reutiliza componentes. Interacción entre componentes usando @Input() y
                        EventEmmiter con Angular 8".
                    </a>
                </i>
            </li>
        </ol>
    </blockquote>

    <h2>Paso 0: Corregir bug en el componente “tabla-registros”</h2>

    <p>
        El bug consiste en que la paginación de la tabla de registros no funciona correctamente. Esto es causado por que
        los
        elementos del paginador y el sorteador se conectan a la fuente de datos de la tabla en el constructor del
        componente.
    </p>
    <p>
        Para corregir esto, debemos mover este código al método ngOnInit(). Modifica el siguiente código en
        “tabla-registros.component.ts”:
    </p>
    <pre><code>...
dataSource = new MatTableDataSource&lt;MedicionGlucosa&gt;(this._registros);
...
constructor() &#123;
&#125;

ngOnInit() &#123;
this.dataSource.paginator = this.paginator;
this.dataSource.sort = this.sort;
&#125;
...
</code></pre>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack4/01-BugFix.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack4/01-BugFix.png" /></a>
        </span>
    </p>

    <p>
        El primer cambio consiste en declarar e inicializar la tabla con los datos en la propiedad “this._registros”.
    </p>
    <p>
        Después eliminamos todo el contenido del método constructor del componente y lo pasamos al método “ngOnInit()”.
        Ya no es necesario inicializar los datos de la tabla así que solo dejamos el código que conecta el paginador y
        el sorteador a la tabla.
    </p>
    <p>
        Después de hacer estos cambios, el paginador de la tabla funciona correctamente.
    </p>

    <h2>Paso 1: Generar registros de prueba (opcional)</h2>
    <p>
        Para generar registros con datos aleatorios para visualizarlos en las gráficas que implementaremos en el
        dashboard, agrega el siguiente código en el servicio “mediciones.service.ts”:
    </p>

    <pre><code>...
export class MedicionesService &#123;
    debugMode = true;
    
    ...
    
    constructor() &#123;
        ...
        if (this.debugMode) &#123;
            this.CrearDatosDePrueba();
        &#125;
    &#125;
    
    ...
    
    private CrearDatosDePrueba() &#123;
        if (this.GetAll().length &lt; 2000) &#123;
            localStorage.setItem(this.storageKey, JSON.stringify(&#91;&#93; as MedicionGlucosa&#91;&#93;));
            const fechaA = new Date();
            const fechaB = new Date();
            fechaA.setMonth(fechaA.getMonth() &#45; 24);
            
            while (fechaA &lt; fechaB) &#123;
                let medicion = this.CrearMedicionRandom('Desayuno', fechaA);
                this.Create(medicion);
                medicion = this.CrearMedicionRandom('Comida', fechaA);
                this.Create(medicion);
                medicion = this.CrearMedicionRandom('Cena', fechaA);
                this.Create(medicion);
                fechaA.setDate(fechaA.getDate() + 1);
            &#125;
        &#125;
    &#125;
    
    private CrearMedicionRandom(comida: string, fecha: Date) &#123;
        let rnd = (Math.random() * 130) + 60;
        const nivelGlucosa = rnd;
        
        rnd = (Math.floor(Math.random() * 100) % 2);
        const antesODespues = rnd === 0 ? 'Antes' : 'Despues';
        
        const medicion: MedicionGlucosa = &#123;
            Id: this.NewGuid(),
            Timestamp: new Date(),
            Nivel: nivelGlucosa,
            Comida: comida,
            AntesDespues: antesODespues,
            Fecha: fecha
        &#125;;
        
        return medicion;
    &#125;
&#125;
</code></pre>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack4/02-UpdateService.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack4/02-UpdateService.png" /></a>
        </span>
    </p>

    <p>Los cambios consisten en lo siguiente:</p>
    <p>
        <ol>
            <li>Creamos una propiedad booleana “debugMode”.</li>
            <li>En el método constructor, si la propiedad “debugMode” es igual a “true” el servicio va a precargar datos
                de prueba en la aplicación llamando al método “CrearDatosDePrueba()”.</li>
            <li>El método “CrearDatosDePrueba()” genera 3 registros diarios de mediciones por cada día de los últimos 2
                años utilizando el método “CrearMedicionRandom()”.</li>
            <li>El método “CrearMedicionRandom()” genera valores pseudoaleatorios para generar registros de niveles de
                glucosa que se encuentren dentro de rangos realistas.</li>
        </ol>
    </p>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack4/03-DummyRecords.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack4/03-DummyRecords.png" /></a>
        </span>
    </p>

    <p>Para deshabilitar este comportamiento, cambia el valor de la propiedad “debugMode” a “false”.</p>

    <h2>Paso 2: Actualizar estilos en el dashboard de la aplicación</h2>

    <p>
        La página principal de la aplicación debe mostrar el contenido de manera ordenada para que todos los datos y
        graficas sean más fácil de entender. Para esto vamos a agregar los siguientes estilos en el archivo
        “dashboard.component.css”:
    </p>

    <pre><code>.flex&#45;row &#123;
    display: flex;
    width: 100%;
    flex&#45;wrap: wrap;
    padding&#45;bottom: 20px;
&#125;
    
.flex&#45;row&#45;item.uno &#123;
    width: 100%;
&#125;

.flex&#45;row&#45;item.dos &#123;
    width: 50%;
&#125;

.flex&#45;row&#45;item mat&#45;card &#123;
    margin&#45;right: 10px;
&#125;

.flex&#45;row&#45;item:last&#45;child mat&#45;card &#123;
    margin&#45;right: 0px;
&#125;
</code></pre>

    <p>
        Ahora agregaremos algunos componentes “mat-card” de Angular Material que nos servirán como contenedores para las
        gráficas que se van a mostrar en la aplicación. Actualiza el contenido de “dashboard.component.html”:
    </p>

    <pre><code>&lt;div class="flex&#45;row"&gt;
    &lt;div class="flex&#45;row&#45;item uno"&gt;
        &lt;mat&#45;card&gt;
            &lt;p&gt;RCKSTR1.GitHub.io&lt;/p&gt;
        &lt;/mat&#45;card&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class="flex&#45;row"&gt;
    &lt;div class="flex&#45;row&#45;item dos"&gt;
        &lt;mat&#45;card&gt;
            &lt;p&gt;RCKSTR1.GitHub.io&lt;/p&gt;
        &lt;/mat&#45;card&gt;
    &lt;/div&gt;
    &lt;div class="flex&#45;row&#45;item dos"&gt;
        &lt;mat&#45;card&gt;
            &lt;p&gt;RCKSTR1.GitHub.io&lt;/p&gt;
        &lt;/mat&#45;card&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class="flex&#45;row"&gt;
    &lt;div class="flex&#45;row&#45;item uno"&gt;
        &lt;mat&#45;card&gt;
            &lt;mat&#45;card&#45;title&gt;Mis registros&lt;/mat&#45;card&#45;title&gt;
            &lt;app&#45;tabla&#45;registros &#91;permitirEliminar&#93;="false" &#91;registros&#93;="registros"&gt;
            &lt;/app&#45;tabla&#45;registros&gt;
        &lt;/mat&#45;card&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack4/04-DashboardLayout.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack4/04-DashboardLayout.png" /></a>
        </span>
    </p>

    <h2>Paso 3: Instalar ng2-charts y Chart.js</h2>

    <p>
        Ng2-charts es un paquete de directivas de Angular para Chart.js que estaremos utilizando para crear graficas en
        Angular 8 utilizaremos ng2-charts.
    </p>

    <p>En la terminal, ejecuta los siguientes comandos:</p>

    <h4>Instala ng2-charts</h4>
    <pre><code>npm install --save ng2-charts</code></pre>

    <h4>Instala Chart.js</h4>
    <pre><code>npm install --save chart.js</code></pre>

    <h4>Importa ng2-charts</h4>
    <p>Agrega el siguiente código en “App.module.ts”:</p>

    <pre><code>...    
import &#123; ChartsModule &#125; from 'ng2&#45;charts';

@NgModule(&#123;
    declarations: &#91;
        ...
    &#93;,
    imports: &#91;
        ...
        ChartsModule
    &#93;,
    ...
&#125;)
export class AppModule &#123; &#125;
</code></pre>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack4/05-ImportChartModule.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack4/05-ImportChartModule.png" /></a>
        </span>
    </p>

    <h4>Instala los schematics de ng2-charts para generar componentes que implementen graficas más rápidamente.</h4>

    <pre><code>npm install --save-dev ng2-charts-schematics</code></pre>

    <h2>Paso 4: Crear gráficas utilizando schematics de ng2-charts</h2>

    <p>
        A continuación, generaremos de manera automática componentes con implementaciones de gráficas de Charts.js
        utilizando los schematics que instalamos en el paso anterior. Ejecuta los siguientes comandos en la terminal
        para generar los nuevos componentes:
    </p>
    <pre><code>ng generate ng2-charts-schematics:line components/historico-mediciones-chart
ng generate ng2-charts-schematics:bar components/comparativo-mensual-chart
ng generate ng2-charts-schematics:pie components/global-niveles-chart
    </code></pre>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack4/06-NuevosComponentes.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack4/06-NuevosComponentes.png" /></a>
        </span>
    </p>

    <h3>Implementar los nuevos componentes al dashboard</h3>

    <p>
        Para mostrar los componentes que acabamos de generar, actualiza el contenido de “dashboard.component.html”:
    </p>

    <pre><code>&lt;div class="flex&#45;row"&gt;
    &lt;div class="flex&#45;row&#45;item uno"&gt;
        &lt;mat&#45;card&gt;
            &lt;app&#45;historico&#45;mediciones&#45;chart&gt;&lt;/app&#45;historico&#45;mediciones&#45;chart&gt;
        &lt;/mat&#45;card&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class="flex&#45;row"&gt;
    &lt;div class="flex&#45;row&#45;item dos"&gt;
        &lt;mat&#45;card&gt;
            &lt;app&#45;comparativo&#45;mensual&#45;chart&gt;&lt;/app&#45;comparativo&#45;mensual&#45;chart&gt;
        &lt;/mat&#45;card&gt;
    &lt;/div&gt;
    &lt;div class="flex&#45;row&#45;item dos"&gt;
        &lt;mat&#45;card&gt;
            &lt;app&#45;global&#45;niveles&#45;chart&gt;&lt;/app&#45;global&#45;niveles&#45;chart&gt;
        &lt;/mat&#45;card&gt;
    &lt;/div&gt;
&lt;/div&gt;
...
</code></pre>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack4/07-BoilerplateCharts.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack4/07-BoilerplateCharts.png" /></a>
        </span>
    </p>

    <p>Ahora se muestran los nuevos componentes que acabamos de generar.</p>




    <hr>
    <h1>OLD CONTENTOLD CONTENTOLD CONTENTOLD CONTENTOLD CONTENTOLD CONTENT</h1>
    <hr>
    <p>
        Me han comentado que los posts anteriores pueden ser demasiado largos y no tan fáciles de entender. Voy a tratar
        de mantener los posts más breves y al mismo tiempo explicarlos mejor. Aunque creo que este post tampoco quedó
        tan corto, espero que si esté más claro.
    </p>


    <p>
        Hoy comenzaremos a modificar el Dashboard, la página principal de la aplicación. Lo primero que haremos es
        agregar al dashboard una tabla igual a la que tenemos en la página de registro.
    </p>


    <h2>Paso 1: Crear nuevo componente</h2>
    <p>
        La manera incorrecta de agregar la tabla de registro a la página principal sería copiar el código de la tabla de
        la página de registro y pegarlo en el componente Dashboard. En cambio, lo que vamos a hacer es crear un
        componente reutilizable que podamos utilizar en la página de registro y en el dashboard sin tener código
        duplicado en la aplicación.
    </p>

    <div class="row">
        <div class="6u 12u$(small)">
            <p>
                Comenzaremos creando un componente nuevo desde la consola:
            </p>
        </div>
        <div class="6u 12u$(small)">
            <pre><code>ng generate component components/tabla-registros</code></pre>
        </div>
    </div>


    <p>
        Ahora, inserta el nuevo componente en la página de registro:
    </p>


    <div class="row">
        <div class="6u 12u$(small)">
            <pre><code>
&lt;h1&gt;Niveles de glucosa&lt;/h1&gt;
&lt;mat&#45;card&gt;
    ...
&lt;/mat&#45;card&gt;

&lt;mat&#45;card&gt;
    &lt;mat&#45;card&#45;title&gt;Mis registros&lt;/mat&#45;card&#45;title&gt;
    
    &lt;app&#45;tabla&#45;registros&gt;&lt;/app&#45;tabla&#45;registros&gt;
    ...
&lt;/mat&#45;card&gt;</code></pre>
        </div>
        <div class="6u 12u$(small)">
            <span class="image fit">
                <a href="/assets/images/blog/GLTrack3/01-NuevoComponent.png" target="_blank"><img alt=""
                        src="/assets/images/blog/GLTrack3/01-NuevoComponent.png" /></a>
            </span>
        </div>
    </div>

    <h2>Paso 2: Mover y adecuar el código de la tabla en el nuevo componente</h2>
    <h3>Código HTML</h3>
    <p>
        Comenzamos moviendo el código HTML de la tabla desde "registro.component.html" hacia
        "tabla-registros.component.html".
    </p>
    <p>
        registro.component.html:
    </p>

    <pre><code>&lt;h1&gt;Niveles de glucosa&lt;/h1&gt;
&lt;mat&#45;card&gt;
    ...
&lt;/mat&#45;card&gt;

&lt;mat&#45;card&gt;
    &lt;mat&#45;card&#45;title&gt;Mis registros&lt;/mat&#45;card&#45;title&gt;

    &lt;app&#45;tabla&#45;registros&gt;&lt;/app&#45;tabla&#45;registros&gt;

    &lt;!&#45; El codigo estaba aqui &#45;&gt;
&lt;/mat&#45;card&gt;
</code></pre>
    <p>
        tabla-registros.component.html:
    </p>
    <pre><code>&lt;div class="row"&gt;
    &lt;mat&#45;form&#45;field class="row&#45;item grow"&gt;
        &lt;input matInput (keyup)="applyFilter(&#36;event.target.value)" placeholder="Buscar"&gt;
    &lt;/mat&#45;form&#45;field&gt;
&lt;/div&gt;

&lt;table mat&#45;table &#91;dataSource&#93;="dataSource" matSort&gt;
    &lt;ng&#45;container matColumnDef="fecha"&gt;
        &lt;th mat&#45;header&#45;cell *matHeaderCellDef mat&#45;sort&#45;header&gt; Fecha &lt;/th&gt;
        &lt;td mat&#45;cell *matCellDef="let row"&gt; &#123;row.Fecha|date:'medium'&#125; &lt;/td&gt;
    &lt;/ng&#45;container&gt;

    &lt;ng&#45;container matColumnDef="nivel"&gt;
        &lt;th mat&#45;header&#45;cell *matHeaderCellDef mat&#45;sort&#45;header&gt; ID &lt;/th&gt;
        &lt;td mat&#45;cell *matCellDef="let row"&gt; &#123;row.Nivel&#125; &lt;/td&gt;
    &lt;/ng&#45;container&gt;

    &lt;ng&#45;container matColumnDef="comida"&gt;
        &lt;th mat&#45;header&#45;cell *matHeaderCellDef mat&#45;sort&#45;header&gt; Comida &lt;/th&gt;
        &lt;td mat&#45;cell *matCellDef="let row"&gt; &#123;row.Comida&#125; &lt;/td&gt;
    &lt;/ng&#45;container&gt;

    &lt;ng&#45;container matColumnDef="antesDespues"&gt;
        &lt;th mat&#45;header&#45;cell *matHeaderCellDef mat&#45;sort&#45;header&gt; Antes/Después &lt;/th&gt;
        &lt;td mat&#45;cell *matCellDef="let row"&gt; &#123;row.AntesDespues&#125; &lt;/td&gt;
    &lt;/ng&#45;container&gt;

    &lt;ng&#45;container matColumnDef="actions"&gt;
        &lt;th mat&#45;header&#45;cell *matHeaderCellDef&gt; &lt;/th&gt;
        &lt;td mat&#45;cell *matCellDef="let row"&gt;
            &lt;button mat&#45;icon&#45;button (click)="Eliminar(row.Id)"&gt;
                &lt;mat&#45;icon&gt;delete&lt;/mat&#45;icon&gt;
            &lt;/button&gt;
        &lt;/td&gt;
    &lt;/ng&#45;container&gt;

    &lt;tr mat&#45;header&#45;row *matHeaderRowDef="displayedColumns"&gt;&lt;/tr&gt;
    &lt;tr mat&#45;row *matRowDef="let row; columns: displayedColumns;"&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;mat&#45;paginator &#91;pageSizeOptions&#93;="&#91;5, 10, 25, 100&#93;"&gt;&lt;/mat&#45;paginator&gt;
</code></pre>

    <h3>Código Typescript</h3>

    <p>
        Ahora continuamos moviendo el código de la tabla desde el archivo registro.component.ts hacia
        tabla-registros.component.ts. Para más claridad, a continuación, se muestra el código comentado en
        registro.component.ts:
    </p>



    <p>
        Puedes eliminar las líneas comentadas una vez que las pegas en "tabla-registros.component.ts":
    </p>



    <p>
        Ahora el componente “tabla-registros.component” se muestra correctamente, pero la tabla aparece vacía, aunque
        tengamos registros capturados. Esto es porque, aunque la tabla tiene todos los elementos para almacenar y
        mostrar datos, no tenemos manera de comunicarnos con el componente para enviar o recibir datos.
    </p>

    <h2>Paso 3: Pasar datos al componente utilizando @Input()</h2>

    <div class="row">
        <div class="6u 12u$(small)">
            <p>
                Para pasar datos de un componente a otro, en este caso, desde el componente “registro” hacia
                “tabla-registros” necesitamos agregar una propiedad al componente con el decorador @Input().
            </p>

            <p>
                Modifica la propiedad “registros” e inserta el siguiente código en tabla-registros.component.ts:
            </p>
        </div>
        <div class="6u 12u$(small)">
            <pre><code>// registros = &#91;&#93; as MedicionGlucosa&#91;&#93;;
_registros = &#91;&#93; as MedicionGlucosa&#91;&#93;;

@Input()
set registros(value: MedicionGlucosa&#91;&#93;) &#123;
    this._registros = value;
    this.dataSource.data = this._registros;
&#125;
</code></pre>
        </div>
    </div>


    <p>
        Lo primero que hacemos es cambiar el nombre del arreglo de mediciones en la tabla de “registros” a “_registros”.
        Esto es porque estamos agregando una nueva propiedad con el nombre “registros”. El decorador @Input() indica que
        el valor de esta propiedad puede asignarse desde otro componente. La manera más sencilla de utilizar @Input() es
        la siguiente:
    </p>

    <pre><code>@Input() registros: MedicionGlucosa[] = [];</code></pre>

    <p>Sin embargo, en este caso necesitamos ejecutar algunas operaciones cuando el valor de la propiedad “registros”
        cambia:</p>

    <div class="row">
        <div class="6u 12u$(small)">
            <ol>
                <li>Primero, tomamos el valor recibido “value” y lo guardamos en el arreglo “_registros”.</li>
                <li>Actualiza la fuente de datos de la tabla de angular material (mat-table).</li>
            </ol>
        </div>
        <div class="6u 12u$(small)">
            <span class="image fit">
                <a href="/assets/images/blog/GLTrack3/02-Input.png" target="_blank"><img alt=""
                        src="/assets/images/blog/GLTrack3/02-Input.png" /></a>
            </span>
        </div>
    </div>

    <p>
        Ahora que tenemos una forma de recibir datos, agrega el siguiente atributo al componente “tabla-registros” en
        "registro.component.html":
    </p>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack3/03-PassDataToInput.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack3/03-PassDataToInput.png" /></a>
        </span>
    </p>

    <div class="row">
        <div class="6u 12u$(small)">
            <p>
                De esta manera, estamos indicando que el contenido de la propiedad “registros” del componente
                “registro.component” va a insertarse a la propiedad de entrada “[registros]” del componente
                “tabla-registros”.
            </p>

            <p>
                Ahora podemos observar que la tabla que ahora existe dentro del componente “tabla-registros” está
                mostrando los datos que recibe desde el componente “registro”.
            </p>
        </div>
        <div class="6u 12u$(small)">
            <span class="image fit">
                <a href="/assets/images/blog/GLTrack3/04-DataInputWorks.png" target="_blank"><img alt=""
                        src="/assets/images/blog/GLTrack3/04-DataInputWorks.png" /></a>
            </span>
        </div>
    </div>

    <h2>Paso 4: Escuchar eventos de un componente utilizando EventEmmiter&lt;T&gt;</h2>

    <div class="row">
        <div class="6u 12u$(small)">
            <p>
                Aunque el componente “tabla-registros” puede recibir datos. Al hacer click en el botón para eliminar un
                registro, podemos observar que, en lugar de eliminar el registro, la consola del navegador arroja un
                error:
            </p>
            <span class="image fit">
                <a href="/assets/images/blog/GLTrack3/05-Error.png" target="_blank"><img alt=""
                        src="/assets/images/blog/GLTrack3/05-Error.png" /></a>
            </span>

        </div>
        <div class="6u 12u$(small)">

            <p>
                Esto sucede porque el botón eliminar intenta ejecutar la función “Eliminar()” cuando el usuario hace
                click y esta función no existe todavía en el componente:
            </p>
            <span class="image fit">
                <a href="/assets/images/blog/GLTrack3/06-Eliminar.png" target="_blank"><img alt=""
                        src="/assets/images/blog/GLTrack3/06-Eliminar.png" /></a>
            </span>

            <p>
                Para solucionar esto, crea la función “Eliminar()” en tabla-registros.component.ts agregando el
                siguiente código:
            </p>
        </div>
    </div>

    <div class="row">
        <div class="6u 12u$(small)">
            <p>
                Primero estamos creando una propiedad de tipo EventEmmiter&lt;string&gt; y decorándola con “@Output()”.
                Después, en la función “Eliminar()” estamos recibiendo como parámetro el Id del registro a eliminar y
                emitiendo el evento “itemDeleted” con el Id recibido.
            </p>
        </div>
        <div class="6u 12u$(small)">
            <pre><code>export class TablaRegistrosComponent implements OnInit &#123;
    ...
    @Output() itemDeleted = new EventEmitter&lt;string&gt;();
    ...
    Eliminar(id: string) &#123;
        this.itemDeleted.emit(id);
    &#125;
&#125;
</code></pre>
        </div>
    </div>
    <p>
        Anteriormente, el código para eliminar un registro estaba dentro de la función Eliminar, sin embargo, el
        componente “tabla-registros” tiene como única responsabilidad mostrar datos en la pantalla y notificar a otros
        componentes acerca de las interacciones del usuario, por ejemplo, cuando el usuario hace click en el botón
        eliminar.
    </p>

    <h3>@Output()</h3>
    <p>
        El decorador “@Output()” indica que podemos leer el valor de la propiedad desde otro componente, de una manera
        muy similar a como lo hacemos con el decorador “@Input()”.
    </p>

    <h3>EventEmmiter&lt;T&gt;</h3>

    <div class="row">
        <div class="7u 12u$(small)">
            <p>
                EventEmmiter es una clase incluida en Angular que se usa en propiedades con el decorador “@Output()”
                para emitir eventos personalizados a los que podemos suscribirnos. “&lt;T&gt;” indica que al crear un
                EventEmmiter podemos configurar el tipo de dato que va a incluir el evento. En este caso estamos
                configurando el evento para contener un string.
            </p>
        </div>
        <div class="5u 12u$(small)">
            <span class="image fit">
                <a href="/assets/images/blog/GLTrack3/07-EventEmmiter.png" target="_blank"><img alt=""
                        src="/assets/images/blog/GLTrack3/07-EventEmmiter.png" /></a>
            </span>
        </div>
    </div>

    <div class="row">
        <div class="6u 12u$(small)">
            <span class="image fit">
                <a href="/assets/images/blog/GLTrack3/08-ListenToOutput.png" target="_blank"><img alt=""
                        src="/assets/images/blog/GLTrack3/08-ListenToOutput.png" /></a>
            </span>
        </div>
        <div class="6u 12u$(small)">
            <p>
                Ahora que tenemos listo el EventEmmiter, podemos suscribirnos al evento itemDeleted para ejecutar alguna
                función cuando sea invocado. Agrega el siguiente atributo a “app-tabla-registros” en
                registro.component.html:
            </p>
        </div>
    </div>

    <p>
        De esta manera, el componente “registro.component” queda suscrito al evento, y cuando el usuario haga click en
        el botón eliminar, el componente “tabla-registros” dispara el evento “itemDeleted” y entonces el componente
        “registro.component” ejecuta la función “Eliminar()”.
    </p>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack3/09-EventChain.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack3/09-EventChain.png" /></a>
        </span>
    </p>

    <p>
        <ol>
            <li>Cuando el usuario hace click en el botón para eliminar un registro, el componente “tabla-registros”
                ejecuta la función “Eliminar()”.</li>
            <li>La función “Eliminar()” en “tabla-registros.component.ts” emite el evento “itemDeleted” que contiene el
                Id del registro a eliminar.</li>
            <li>El componente “registro.component” está suscrito al evento, y cuando el evento se emite, ejecuta la
                función “Eliminar()” pasando como parámetro el Id del registro a eliminar.</li>
            <li>La función “Eliminar()” en “registro.component.ts” se encarga de recibir el Id del registro a eliminar y
                llama al servicio encargado del almacenamiento de datos para que sea eliminado.</li>
        </ol>
    </p>

    <h2>Paso 5: Reutilizar el componente “tabla-registros”</h2>
    <div class="row">
        <div class="6u 12u$(small)">
            <p>
                Ahora que tenemos un componente independiente y reutilizable, podemos insertar la tabla de registros en
                la página principal de la aplicación. Agrega el componente al dashboard con el siguiente código en
                dashboard.component.html:
            </p>
        </div>
        <div class="6u 12u$(small)">
            <pre><code>...
&lt;mat&#45;card&gt;
    &lt;app&#45;tabla&#45;registros&gt;&lt;/app&#45;tabla&#45;registros&gt;
&lt;/mat&#45;card&gt;</code></pre>
        </div>
    </div>


    <p>
        La tabla se muestra correctamente, pero de nuevo nos encontramos con que no tiene datos para mostrar. Esto es
        porque el componente “tabla-registros” necesita recibir los datos a través del atributo de entrada
        “[registros]”.
    </p>
    <p>
        Ahora debemos actualizar “dashboard.component.ts” para que recupere los datos y los pase a la tabla:
    </p>

    <pre><code>...
export class DashboardComponent implements OnInit &#123;
registros = &#91;&#93; as MedicionGlucosa&#91;&#93;;

    constructor(private mediciones: MedicionesService) &#123;
    &#125;

    ngOnInit() &#123;
        this.registros = this.mediciones.GetAll();
    &#125;
&#125;
</code></pre>

    <p>
        Ahora el componente tiene una propiedad “registros” que contiene los registros capturados por el usuario.
    </p>

    <p>
        Utilizando Dependency Injection de Angular, en el constructor se está inyectando el servicio “MedicionesService”
        que se encarga de leer y escribir los registros de mediciones. De esta manera, Angular se encarga de que una
        instancia del servicio esté disponible en el componente.
    </p>

    <p>
        Después, en la función “ngOnInit()” indicamos que una vez que el componente se cargue, recupere los registros de
        mediciones y los guarde en la propiedad “registros”.
    </p>

    <p>
        Por último, necesitamos pasar los registros al componente “tabla-registros” utilizando el atributo de entrada
        “[registros]”. Actualiza “dashboard.component.html”:
    </p>

    <div class="row">
        <div class="8u 12u$(small)">
            <p>
                Ahora la tabla de registros está disponible también en la página principal reutilizando el componente
                “tabla-registros” sin la necesidad de tener código duplicado. De esta manera la aplicación es más fácil
                de actualizar y mantener.
            </p>
        </div>
        <div class="4u 12u$(small)">
            <span class="image fit">
                <a href="/assets/images/blog/GLTrack3/10-DashboardTableCode.png" target="_blank"><img alt=""
                        src="/assets/images/blog/GLTrack3/10-DashboardTableCode.png" /></a>
            </span>
        </div>
    </div>

    <h3>Nuevo problema</h3>

    <div class="row">
        <div class="4u 12u$(small)">
            <span class="image fit">
                <a href="/assets/images/blog/GLTrack3/11-DashboardTableView.png" target="_blank"><img alt=""
                        src="/assets/images/blog/GLTrack3/11-DashboardTableView.png" /></a>
            </span>
        </div>
        <div class="8u 12u$(small)">
            <p>
                Ahora tenemos un nuevo problema. Supongamos que, por seguridad, el usuario debe poder eliminar capturas
                de mediciones desde la página de registro, pero no desde la página principal de la aplicación.
            </p>
            <p>
                Necesitamos actualizar el componente “tabla-registros” para que podamos configurar si los botones para
                eliminar registros están disponibles en ciertos casos.
            </p>
        </div>
    </div>

    <p>
        Para esto, necesitamos hacer algunas modificaciones en “tabla-registros.component.ts”:
    </p>

    <pre><code>...
export class TablaRegistrosComponent implements OnInit &#123;
    …
    @Input() permitirEliminar = true;
    …
    // displayedColumns: string&#91;&#93; = &#91;'fecha', 'nivel', 'comida', 'antesDespues', 'actions'&#93;;
    …
    GetDisplayerColumns() &#123;
        const displayedColumns: string&#91;&#93; = &#91;'fecha', 'nivel', 'comida', 'antesDespues'&#93;;
        if (this.permitirEliminar) &#123;
            displayedColumns.push('actions');
        &#125;

        return displayedColumns;
    &#125;
&#125;
</code></pre>

    <p>
        Estas modificaciones consisten en lo siguiente:
    </p>

    <p>
        <ol>
            <li>Agregamos una nueva propiedad de entrada “permitirEliminar”, con un valor verdadero (“true”) por
                default.</li>
            <li>Eliminamos la propiedad “displayedColumns” que guardaba un arreglo con los nombres de las columnas que
                se muestran en la tabla.</li>
            <li>
                Creamos una función nueva “GetDisplayedColumns()” que tiene como valor de retorno un arreglo con los
                nombres de las columnas que se mostrarán en la tabla. Esta función evalúa el valor de la propiedad
                “permitirEliminar” y si es verdadero entonces agrega la columna “actions” que es la que contiene el
                botón para eliminar registros.
            </li>
        </ol>
    </p>

    <p>
        Ahora necesitamos actualizar “tabla-registros.component.html” para que lea la lista de columnas desde la función
        “GetDisplayedColumns()” que acabamos de crear:
    </p>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack3/12-GetDisplayedColumns().png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack3/12-GetDisplayedColumns().png" /></a>
        </span>
    </p>

    <p>
        De esta manera, el componente “tabla-registros” muestra los botones para eliminar por default, pero ahora
        podemos configurarlo para ocultarlos si es necesario.
    </p>

    <p>
        Para ocultar los botones en la pantalla principal de la aplicación, agrega el atributo de entrada
        “permitirEliminar” en “dashboard.component.html”:
    </p>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack3/13-PermitirEliminar.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack3/13-PermitirEliminar.png" /></a>
        </span>
    </p>

    <p>
        De esta manera, evitamos que la tabla muestre los botones para eliminar registros en el dashboard de la
        aplicación.
    </p>

    <p style="text-align:center !important;">
        <span class="image">
            <a href="/assets/images/blog/GLTrack3/14-NoDeleteButton.png" target="_blank"><img alt=""
                    src="/assets/images/blog/GLTrack3/14-NoDeleteButton.png" /></a>
        </span>
    </p>

    <h2>Conclusión</h2>

    <p>
        En este post continuamos construyendo GLTrack, una aplicación para registro de mediciones de glucosa en la
        sangre para pacientes de diabetes.
    </p>
    <p>
        Para evitar tener código duplicado en la aplicación, creamos un componente reutilizable para mostrar la tabla de
        registros en la página principal y en la página de registros de la aplicación.
    </p>
    <p>
        Utilizamos los decoradores “@Input()” y “@Output()” así como EventEmmiter&lt;T&gt; para interactuar entre
        componentes de angular y pasar datos de entrada y salida.
    </p>
    <p>
        También reutilizamos servicios de angular en diferentes componentes con Dependency Injection de Angular 8.
    </p>
    <p>
        En el siguiente post, continuaremos trabajando en el Dashboard de la aplicación, para mostrar datos relevantes
        para el usuario acerca de sus mediciones de glucosa a través de graficas que muestren los datos capturados en la
        aplicación de manera visual.
    </p>

    <p>El código fuente completo de la aplicación de ejemplo puedes encontrarlo en GitHub, en
        <a href="https://github.com/RCKSTR1/GLTrack3" target="_blank">https://github.com/RCKSTR1/GLTrack3</a>
        o si prefieres, puedes clonar el repositorio directo en https://github.com/RCKSTR1/GLTrack3.git
    </p>
    <p>
        Si tuviste algún problema o duda al seguir los pasos, o si tienes alguna pregunta acerca de este post,
        contáctame en Twitter, Facebook o LinkedIn.
    </p>

    <p>
        <strong>Es cuánto.</strong>
    </p>

    <h2>Fuentes</h2>
    <ul>
        <li>Documentación de Angular. "Propiedades de @Input() y @Output()".
            <a href="https://angular.io/guide/template-syntax#input-and-output-properties"
                target="_blank">https://angular.io/guide/template-syntax#input-and-output-properties</a>
        </li>
        <li>Documentación de Angular. "EventEmitter".
            <a href="https://angular.io/api/core/EventEmitter#eventemitter"
                target="_blank">https://angular.io/api/core/EventEmitter#eventemitter</a>
        </li>
    </ul>
</div>
